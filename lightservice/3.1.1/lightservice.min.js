//lightservice 3.1.1
//Samuel B
var light = function () { function e() { for (var e = !1, n = 0; n < t.length; n++) { try { e = t[n]() } catch (r) { continue } break } return e } function n(e) { return "[object Array]" === Object.prototype.toString.call(e) } var r = {}; r.DEFAULT_HANDLE_NAME = "$$default", r.entranceTag = "argument", r.exitTag = "result", r.serviceTag = "service", r.handleTag = "handle", r.eventTag = "event", r.unknownTag = "unknown", r._TEST_OBJECTS_, r.systemServices = {}, r.registry = { service: {}, handle: {}, scripts: {} }, r.burnThread = function (e) { for (var n = (new Date).getTime() + 1e3 * e; (new Date).getTime() <= n;); }, r.isRegistered = function (e) { return r.registry.service[e] || r.registry.handle[e] ? !0 : !1 }; var t = [function () { return new XMLHttpRequest }, function () { return new ActiveXObject("Msxml2.XMLHTTP") }, function () { return new ActiveXObject("Msxml3.XMLHTTP") }, function () { return new ActiveXObject("Microsoft.XMLHTTP") }]; r.generateUniqueSystemName = function (e) { e = e || ""; var n = (e + "_xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx").replace(/[xy]/g, function (e) { var n = 16 * Math.random() | 0, r = "x" == e ? n : 3 & n | 8; return r.toString(16) }); return r.isRegistered(n) ? r.generateUniqueSystemName(e) : n }, r.loadScript = function (e, n) { n ? r.loadScriptAsync(e, n) : r.loadScriptSync(e) }, r.loadScriptAsync = function (e, n) { if (!document) throw "Cannot load script : no document"; var r = document.createElement("script"); r.src = e, r.onload = "function" == typeof n ? n : function () { }, document.getElementsByTagName("head")[0].appendChild(r) }, r.loadScriptSync = function (n) { if (!document) throw "Cannot load script : no document"; var r = e(); r.open("GET", n, !1), r.send(""); var t = document.createElement("script"); t.type = "text/javascript", t.text = r.responseText, document.getElementsByTagName("head")[0].appendChild(t) }, r.eventSubscribers = {}, r.track = { record: function (e) { if (r.track.records = r.track.records || [], r.recordServices && e.methodName !== r.DEFAULT_HANDLE_NAME) { var n = { dataType: e.entranceOrExit, methodType: e.serviceOrHandleMethodName, methodName: e.methodName, time: Date.now ? Date.now() : (new Date).getTime(), position: r.track.records.length, isFirst: e.isFirstCallInServiceRun, isLast: e.isLastCallInServiceRun, data: e.argumentOrReturnData, isTest: e.isTest || !1, info: e.info, infoType: e.infoType }; r.track.records.push(JSON.parse(JSON.stringify(n))), r.track.records[r.track.records.length - 1].link = e.link } }, clearAllRecords: function () { r.track.records = [] } }, r.system = { getRecord: function (e) { return r.track.records = r.track.records || [], r.track.records[e] || [] }, getLastRecord: function () { return r.track.records = r.track.records || [], r.track.records.length ? r.track.records[r.track.records.length - 1] : [] }, play: function (e, n) { var t = this; e = e || 0, n = n || r.track.records.length - 1, S(function (i) { for (var a = i, c = e; n >= c; c++) { var o = t.getRecord(c); if (!o) throw "unable to find service to play service"; o.methodType === r.serviceTag && o.dataType === r.entranceTag && (a = c === e ? a[o.methodName](o.data) : a[o.methodName]()) } a.result() }) }, getAllRecords: function (e, n) { e = e || 0; var t = r.track.records.slice(e, n); return t }, recordStart: function () { r.recordServices = !0 }, recordStop: function () { r.recordServices = !1 }, recordClear: function () { r.track.clearAllRecords() } }, r.utility = {}, r.utility.execSurpressError = function (e, n, r, t) { if (S.event.notify(n, r, t), "function" == typeof e) try { e(n, r, t) } catch (i) { console.error("SUPRESSED ERROR : " + i) } }, r.utility.tryCatch = function (e, n, t, i) { try { var a = n(); r.utility.execSurpressError(function () { t(a, e) }, null, e, "trying-service") } catch (c) { r.utility.execSurpressError(function () { i(c, e) }, c, e, "service-throws") } }, r.handles = []; var i = function (e, n, t) { return i.ref = i.ref || 0, i.ref++, r.eventSubscribers[n] = r.eventSubscribers[n] || {}, r.eventSubscribers[n].sub = r.eventSubscribers[n].sub || [], r.eventSubscribers[n].sub.push({ service: t, ref: i.ref }), i.ref }, a = function (e, n, t) { r.eventSubscribers[n] = r.eventSubscribers[n] || {}, r.eventSubscribers[n].sub = r.eventSubscribers[n].sub || [], r.eventSubscribers[n].notify = r.eventSubscribers[n].notify || function (e, i, a) { for (var c = n, o = r.eventSubscribers[c].sub.length, s = 0; o > s; s++) { var u = r.eventSubscribers[c].sub[s], f = { index: s, notificationType: a }; t(u, e, i, f) } } }, c = function (e, n) { return a(e, n, function (e, n, t, i) { r.utility.tryCatch(t, function () { return e.service() }, function () { }, function () { r.utility.execSurpressError(e.service.error, n, t, i) }) }) }, o = function (e, n, r) { n[e] = function (n) { i(e, r, n) }, a(e, r, function (e, n, r, t) { if ("function" == typeof e) try { e(n, r, t) } catch (i) { } }) }, s = function (e, n, t) { o(n, e, t + "." + n), e[n].notify = r.eventSubscribers[t + "." + n].notify }, u = function (e, n, t) { var a = t + "." + n; e[n] = function (e) { return i(t, a, e) }, e[n].forEachSubscriber = e[n].forEachSubscriber || function (e) { for (var n = r.eventSubscribers[a].sub.length, t = 0; n > t; t++) { var i = r.eventSubscribers[a].sub[t]; e && e(i) } }, c(t, a), e[n].notify = r.eventSubscribers[a].notify }, f = function (e, n, t, i, a) { var c = r._TEST_OBJECTS_ && r._TEST_OBJECTS_[i] && r._TEST_OBJECTS_[i].handleName, o = r._TEST_OBJECTS_ && r._TEST_OBJECTS_[i] && r._TEST_OBJECTS_[i].handle; return r.track.record({ entranceOrExit: r.entranceTag, serviceOrHandleMethodName: r.handleTag, methodName: c, argumentOrReturnData: i, info: a, infoType: r.serviceArgTag, isTest: !0, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: o }), tmpDefinition = o.call(r.systemServices, t, a, r.system), r.track.record({ entranceOrExit: r.exitTag, serviceOrHandleMethodName: r.handleTag, methodName: c, argumentOrReturnData: i, info: r.unknownTag, infoType: r.unknownTag, isTest: !0, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: o }), tmpDefinition }, l = function (e, n, t, i, a, c, o, s) { s && (t = s); for (var u = !1, f = r.handles.length, l = 0; f > l; l++) { var d = r.handles[l]; if (u = t && d.name === t) { r.track.record({ entranceOrExit: r.entranceTag, serviceOrHandleMethodName: r.handleTag, methodName: t, argumentOrReturnData: a, info: c, infoType: r.serviceArgTag, isTest: !1, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: o || d.definition }), tmpDefinition = (o || d.definition).call(r.systemServices, i, c, r.system), r.track.record({ entranceOrExit: r.exitTag, serviceOrHandleMethodName: r.handleTag, methodName: t, argumentOrReturnData: a, info: r.unknownTag, infoType: r.unknownTag, isTest: !1, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: o || d.definition }); break } } return tmpDefinition }, d = function (e, n, t, i, a, c) { var o, s = r._TEST_OBJECTS_ && r._TEST_OBJECTS_[a] && r._TEST_OBJECTS_[a].handleName, u = r._TEST_OBJECTS_ && r._TEST_OBJECTS_[a] && r._TEST_OBJECTS_[a].handle; return o = u && !s ? f(e, n, i, a, c) : l(e, n, t, i, a, c, u, s) }, v = function (e, t, i, a, c, o) { r._TEST_OBJECTS_ && r._TEST_OBJECTS_[c] && r._TEST_OBJECTS_[c].service && (i = r._TEST_OBJECTS_[c].handleNames || i, a = r._TEST_OBJECTS_[c].service || a), i = n(i) ? i : i ? [i] : []; var s, u = i.length; s = o; for (var f = 0; u > f; f++) { var l = i[f], v = d(e, t, l, a, c, s); if ("function" != typeof v) { var T = "Cannot process service or handle '" + c + "' "; throw T += v ? "'" + l + "' service handle must return a function" : "no matching service handle  exists ", console.error(T), T } s = v.call(r.systemServices, s, h(), r.system) } return s }, T = function (e, n, t, i, a) { return u(n, "before", a), u(n, "after", a), u(n, "error", a), u(n, "success", a), function (c, o) { var s = {}; s.arg = c; var u; return e.callerContext = o, r.utility.tryCatch(e, function () { return n.before.notify() }, function (e) { }, function (e) { }), r.utility.tryCatch(e, function () { return r.track.record({ entranceOrExit: r.entranceTag, serviceOrHandleMethodName: r.serviceTag, methodName: a, argumentOrReturnData: s.arg, info: t, infoType: r.handleTag, isTest: !1, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: i }), u = v(e, n, t, i, a, s.arg), r.track.record({ entranceOrExit: r.exitTag, serviceOrHandleMethodName: r.serviceTag, methodName: a, argumentOrReturnData: u, info: t, infoType: r.handleTag, isTest: !1, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: i }), u }, function (r) { return n.success.notify(r, e, "service-success") }, function (t) { return r.track.record({ entranceOrExit: r.exitTag, serviceOrHandleMethodName: r.serviceTag, methodName: a, argumentOrReturnData: t, info: "event:error", infoType: r.eventTag, isTest: !1, isFirstCallInServiceRun: r.unknownTag, isLastCallInServiceRun: r.unknownTag, link: i }), n.error.notify(t, e, "service-error") }), r.utility.tryCatch(e, function () { return n.after.notify() }, function () { }, function () { }), u } }, g = function (e, t, i) { var a = "service_"; if (0 == arguments.length || arguments.length > 3) throw "Cannot create service : problem with service definition"; if (1 == arguments.length) { if ("function" != typeof e) return r.registry.scripts[e] ? { load: function (e) { e && S(e) } } : (r.registry.scripts[e] = !0, { load: function (n) { r.loadScript(e, n && function () { S(n) }) } }); i = e, e = r.generateUniqueSystemName(a), t = r.DEFAULT_HANDLE_NAME } if (2 == arguments.length) { if ("function" != typeof t) throw "service definition has to be a function"; i = t, n(e) ? (t = e, e = r.generateUniqueSystemName(a)) : t = r.DEFAULT_HANDLE_NAME } if (r.isRegistered(e)) throw "Unable to create service with name '" + e + "'.Name already exists in registry"; var c = i, o = { name: e, step: function (n) { S.event.notify(e, o, "service-call"), this.steps.push(n) }, steps: [] }, s = function (e) { return s.redefinition(e) }; return s.redefinition = T(o, s, t, c, e), s.me = e, r.systemServices[e] = s, r.registry.service[e] = {}, e }, m = function (e, n, r) { for (var t in e) n(t); r() }, h = function (e) { h.totalChain = h.totalChain || 0; var n = {}, t = void 0; n.result = function () { var e = t; return t = void 0, e }; var i = function (e) { n[e] = function (e) { return function (i) { var a = arguments.length ? i : t; return t = r.systemServices[e](a), n } }(e) }; if (e) m(r.systemServices, i, function () { e(n) }); else for (var a in r.systemServices) i(a); return n.merge = function (e) { var r; if (t) for (var i in t) r = r || {}, r[i] = t[i]; if (e) for (var i in e) r = r || {}, r[i] = e[i]; return t = r, n }, n }, S = function (e) { h(function (n) { "function" == typeof e && e.call(r.systemServices, n, r.system) }) }; return S.startService = function (e) { S(e) }, S.handle = function (e, n) { var t = "handle_"; if (0 == arguments.length || arguments.length > 2) throw "Cannot create handle : problem with handle definition"; if (1 == arguments.length) { if ("function" != typeof e) throw "handle definition has to be a function"; n = e, e = r.generateUniqueSystemName(t) } if (r.isRegistered(e)) throw "Unable to create handle with name '" + e + "'.Name already exists in registry"; return r.registry.handle[e] = {}, r.handles.push({ name: e, definition: n }), e }, S.service = g, S.advance = { serviceTest: function (e, n) { r._TEST_OBJECTS_ = e, n.call(r.systemServices, h(), r.system), r._TEST_OBJECTS_ = void 0 } }, S.version = 1, s(S, "event", "$system"), S.handle(r.DEFAULT_HANDLE_NAME, function (e) { return e }), S }(); "undefined" != typeof module && "exports" in module && (module.exports = light), "function" == typeof define && define.amd && define("light", [], function () { return light });