//lightservice 3.2.0
//Samuel B
var light = function () { function e() { for (var e = !1, n = 0; n < r.length; n++) { try { e = r[n]() } catch (t) { continue } break } return e } function n(e) { return "[object Array]" === Object.prototype.toString.call(e) } var t = {}; t._STORE_ = {}, t.storeFactory = function (e) { t._STORE_[e] = { store: {}, ref: {}, method: function () { return { get: function (n) { var r = t._STORE_[e].store[n]; return r ? JSON.parse(r).data : r }, set: function (n, r) { t._STORE_[e].store[n] = JSON.stringify({ data: r }) }, setRef: function (n, r) { t._STORE_[e].ref[n] = r }, getRef: function (n) { return t._STORE_[e].ref[n] } } } } }, t.DEFAULT_HANDLE_NAME = "$$default", t.entranceTag = "argument", t.exitTag = "result", t.serviceTag = "service", t.handleTag = "handle", t.eventTag = "event", t.unknownTag = "unknown", t._TEST_OBJECTS_, t.systemServices = {}, t.registry = { service: {}, handle: {}, scripts: {} }, t.burnThread = function (e) { for (var n = (new Date).getTime() + 1e3 * e; (new Date).getTime() <= n;); }, t.isRegistered = function (e) { return t.registry.service[e] || t.registry.handle[e] ? !0 : !1 }; var r = [function () { return new XMLHttpRequest }, function () { return new ActiveXObject("Msxml2.XMLHTTP") }, function () { return new ActiveXObject("Msxml3.XMLHTTP") }, function () { return new ActiveXObject("Microsoft.XMLHTTP") }]; t.generateUniqueSystemName = function (e) { e = e || ""; var n = (e + "_xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx").replace(/[xy]/g, function (e) { var n = 16 * Math.random() | 0, t = "x" == e ? n : 3 & n | 8; return t.toString(16) }); return t.isRegistered(n) ? t.generateUniqueSystemName(e) : n }, t._GLOBAL_SCOPE_NAME = t.generateUniqueSystemName("_GLOBAL_SCOPE_"), t.storeFactory(t._GLOBAL_SCOPE_NAME), t.loadScript = function (e, n) { n ? t.loadScriptAsync(e, n) : t.loadScriptSync(e) }, t.loadScriptAsync = function (e, n) { if (!document) throw "Cannot load script : no document"; var t = document.createElement("script"); t.src = e, t.onload = "function" == typeof n ? n : function () { }, document.getElementsByTagName("head")[0].appendChild(t) }, t.loadScriptSync = function (n) { if (!document) throw "Cannot load script : no document"; var t = e(); t.open("GET", n, !1), t.send(""); var r = document.createElement("script"); r.type = "text/javascript", r.text = t.responseText, document.getElementsByTagName("head")[0].appendChild(r) }, t.eventSubscribers = {}, t.track = { record: function (e) { if (t.track.records = t.track.records || [], t.recordServices && e.methodName !== t.DEFAULT_HANDLE_NAME) { var n = { dataType: e.entranceOrExit, methodType: e.serviceOrHandleMethodName, methodName: e.methodName, time: Date.now ? Date.now() : (new Date).getTime(), position: t.track.records.length, isFirst: e.isFirstCallInServiceRun, isLast: e.isLastCallInServiceRun, data: e.argumentOrReturnData, isTest: e.isTest || !1, info: e.info, infoType: e.infoType, link: "function" == typeof e.link ? e.link.toString() : e.link }; t.track.records.push(JSON.parse(JSON.stringify(n))) } }, clearAllRecords: function () { t.track.records = [] } }, t.system = { getRecord: function (e) { return t.track.records = t.track.records || [], t.track.records[e] || [] }, getLastRecord: function () { return t.track.records = t.track.records || [], t.track.records.length ? t.track.records[t.track.records.length - 1] : [] }, play: function (e, n) { var r = this; e = e || 0, n = n || t.track.records.length - 1, h(function (i) { for (var a = i, o = e; n >= o; o++) { var c = r.getRecord(o); if (!c) throw "unable to find service to play service"; c.methodType === t.serviceTag && c.dataType === t.entranceTag && (a = o === e ? a[c.methodName](c.data) : a[c.methodName]()) } a.result() }) }, getAllRecords: function (e, n) { e = e || 0; var r = t.track.records.slice(e, n); return r }, recordStart: function () { t.recordServices = !0 }, recordStop: function () { t.recordServices = !1 }, recordClear: function () { t.track.clearAllRecords() } }, t.utility = {}, t.utility.execSurpressError = function (e, n, t, r) { if (h.event.notify(n, t, r), "function" == typeof e) try { e(n, t, r) } catch (i) { console.error("SUPRESSED ERROR : " + i) } }, t.utility.tryCatch = function (e, n, r, i) { try { var a = n(); t.utility.execSurpressError(function () { r(a, e) }, null, e, "trying-service") } catch (o) { t.utility.execSurpressError(function () { i(o, e) }, o, e, "service-throws") } }, t.handles = []; var i = function (e, n, r) { return i.ref = i.ref || 0, i.ref++, t.eventSubscribers[n] = t.eventSubscribers[n] || {}, t.eventSubscribers[n].sub = t.eventSubscribers[n].sub || [], t.eventSubscribers[n].sub.push({ service: r, ref: i.ref }), i.ref }, a = function (e, n, r) { t.eventSubscribers[n] = t.eventSubscribers[n] || {}, t.eventSubscribers[n].sub = t.eventSubscribers[n].sub || [], t.eventSubscribers[n].notify = t.eventSubscribers[n].notify || function (e, i, a) { for (var o = n, c = t.eventSubscribers[o].sub.length, s = 0; c > s; s++) { var u = t.eventSubscribers[o].sub[s], f = { index: s, notificationType: a }; r(u, e, i, f) } } }, o = function (e, n) { return a(e, n, function (e, n, r, i) { t.utility.tryCatch(r, function () { return e.service() }, function () { }, function () { t.utility.execSurpressError(e.service.error, n, r, i) }) }) }, c = function (e, n, t) { n[e] = function (n) { i(e, t, n) }, a(e, t, function (e, n, t, r) { if ("function" == typeof e) try { e(n, t, r) } catch (i) { } }) }, s = function (e, n, r) { c(n, e, r + "." + n), e[n].notify = t.eventSubscribers[r + "." + n].notify }, u = function (e, n, r) { var a = r + "." + n; e[n] = function (e) { return i(r, a, e) }, e[n].forEachSubscriber = e[n].forEachSubscriber || function (e) { for (var n = t.eventSubscribers[a].sub.length, r = 0; n > r; r++) { var i = t.eventSubscribers[a].sub[r]; e && e(i) } }, o(r, a), e[n].notify = t.eventSubscribers[a].notify }, f = function (e, n, r, i, a) { var o = t._TEST_OBJECTS_ && t._TEST_OBJECTS_[i] && t._TEST_OBJECTS_[i].handleName, c = t._TEST_OBJECTS_ && t._TEST_OBJECTS_[i] && t._TEST_OBJECTS_[i].handle; return t.track.record({ entranceOrExit: t.entranceTag, serviceOrHandleMethodName: t.handleTag, methodName: o, argumentOrReturnData: i, info: a, infoType: t.serviceArgTag, isTest: !0, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: c }), tmpDefinition = c.call(t.systemServices, r, a, t.system, t._STORE_[i].method()), t.track.record({ entranceOrExit: t.exitTag, serviceOrHandleMethodName: t.handleTag, methodName: o, argumentOrReturnData: i, info: t.unknownTag, infoType: t.unknownTag, isTest: !0, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: c }), tmpDefinition }, l = function (e, n, r, i, a, o, c, s) { s && (r = s); for (var u = !1, f = t.handles.length, l = 0; f > l; l++) { var d = t.handles[l]; if (u = r && d.name === r) { t.track.record({ entranceOrExit: t.entranceTag, serviceOrHandleMethodName: t.handleTag, methodName: r, argumentOrReturnData: a, info: o, infoType: t.serviceArgTag, isTest: !1, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: c || d.definition }), tmpDefinition = (c || d.definition).call(t.systemServices, i, o, t.system, t._STORE_[r].method()), t.track.record({ entranceOrExit: t.exitTag, serviceOrHandleMethodName: t.handleTag, methodName: r, argumentOrReturnData: a, info: t.unknownTag, infoType: t.unknownTag, isTest: !1, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: c || d.definition }); break } } return tmpDefinition }, d = function (e, n, r, i, a, o) { var c, s = t._TEST_OBJECTS_ && t._TEST_OBJECTS_[a] && t._TEST_OBJECTS_[a].handleName, u = t._TEST_OBJECTS_ && t._TEST_OBJECTS_[a] && t._TEST_OBJECTS_[a].handle; return c = u && !s ? f(e, n, i, a, o) : l(e, n, r, i, a, o, u, s) }, T = function (e, r, i, a, o, c) { t._TEST_OBJECTS_ && t._TEST_OBJECTS_[o] && t._TEST_OBJECTS_[o].service && (i = t._TEST_OBJECTS_[o].handleNames || i, a = t._TEST_OBJECTS_[o].service || a), i = n(i) ? i : i ? [i] : []; var s, u = i.length; s = c; for (var f = 0; u > f; f++) { var l = i[f], T = d(e, r, l, a, o, s); if ("function" != typeof T) { var v = "Cannot process service or handle '" + o + "' "; throw v += T ? "'" + l + "' service handle must return a function" : "no matching service handle  exists ", console.error(v), v } s = T.call(t.systemServices, s, m(), t.system, t._STORE_[o].method()) } return s }, v = function (e, n, r, i, a) { return u(n, "before", a), u(n, "after", a), u(n, "error", a), u(n, "success", a), function (o, c) { var s = {}; s.arg = o; var u; return e.callerContext = c, t.utility.tryCatch(e, function () { return n.before.notify() }, function (e) { }, function (e) { }), t.utility.tryCatch(e, function () { return t.track.record({ entranceOrExit: t.entranceTag, serviceOrHandleMethodName: t.serviceTag, methodName: a, argumentOrReturnData: s.arg, info: r, infoType: t.handleTag, isTest: !1, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: i }), u = T(e, n, r, i, a, s.arg), t.track.record({ entranceOrExit: t.exitTag, serviceOrHandleMethodName: t.serviceTag, methodName: a, argumentOrReturnData: u, info: r, infoType: t.handleTag, isTest: !1, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: i }), u }, function (t) { return n.success.notify(t, e, "service-success") }, function (r) { return t.track.record({ entranceOrExit: t.exitTag, serviceOrHandleMethodName: t.serviceTag, methodName: a, argumentOrReturnData: r, info: "event:error", infoType: t.eventTag, isTest: !1, isFirstCallInServiceRun: t.unknownTag, isLastCallInServiceRun: t.unknownTag, link: i }), n.error.notify(r, e, "service-error") }), t.utility.tryCatch(e, function () { return n.after.notify() }, function () { }, function () { }), u } }, S = function (e, r, i) { var a = "service_"; if (0 == arguments.length || arguments.length > 3) throw "Cannot create service : problem with service definition"; if (1 == arguments.length) { if ("function" != typeof e) return t.registry.scripts[e] ? { load: function (e) { e && h(e) } } : (t.registry.scripts[e] = !0, { load: function (n) { t.loadScript(e, n && function () { h(n) }) } }); i = e, e = t.generateUniqueSystemName(a), r = t.DEFAULT_HANDLE_NAME } if (2 == arguments.length) { if ("function" != typeof r) throw "service definition has to be a function"; i = r, n(e) ? (r = e, e = t.generateUniqueSystemName(a)) : r = t.DEFAULT_HANDLE_NAME } if (t.isRegistered(e)) throw "Unable to create service with name '" + e + "'.Name already exists in registry"; var o = i, c = { name: e, step: function (n) { h.event.notify(e, c, "service-call"), this.steps.push(n) }, steps: [] }, s = function (e) { return s.redefinition(e) }; return s.redefinition = v(c, s, r, o, e), s.me = e, t.systemServices[e] = s, t.registry.service[e] = {}, t.storeFactory(e), e }, g = function (e, n, t) { for (var r in e) n(r); t() }, m = function (e) { m.totalChain = m.totalChain || 0; var n = {}, r = void 0; n.result = function () { var e = r; return r = void 0, e }; var i = function (e) { n[e] = function (e) { return function (i) { var a = {}; a.previousOrMostCurrentResultToBePassedToTheNextActor = arguments.length ? i : r; var o = JSON.parse(JSON.stringify(a)).previousOrMostCurrentResultToBePassedToTheNextActor; return r = t.systemServices[e](o), n } }(e) }; if (e) g(t.systemServices, i, function () { e(n) }); else for (var a in t.systemServices) i(a); return n.merge = function (e) { var t; if (r) for (var i in r) t = t || {}, t[i] = r[i]; if (e) for (var i in e) t = t || {}, t[i] = e[i]; return r = t, n }, n }, h = function (e) { m(function (n) { "function" == typeof e && e.call(t.systemServices, n, t.system, t._STORE_[t._GLOBAL_SCOPE_NAME].method()) }) }; return h.startService = function (e) { h(e) }, h.handle = function (e, n) { var r = "handle_"; if (0 == arguments.length || arguments.length > 2) throw "Cannot create handle : problem with handle definition"; if (1 == arguments.length) { if ("function" != typeof e) throw "handle definition has to be a function"; n = e, e = t.generateUniqueSystemName(r) } if (t.isRegistered(e)) throw "Unable to create handle with name '" + e + "'.Name already exists in registry"; return t.registry.handle[e] = {}, t.handles.push({ name: e, definition: n }), t.storeFactory(e), e }, h.service = S, h.advance = { serviceTest: function (e, n) { t._TEST_OBJECTS_ = e, n.call(t.systemServices, m(), t.system, t._STORE_[t._GLOBAL_SCOPE_NAME]), t._TEST_OBJECTS_ = void 0 } }, h.version = 1, s(h, "event", "$system"), h.handle(t.DEFAULT_HANDLE_NAME, function (e) { return e }), h }(); "undefined" != typeof module && "exports" in module && (module.exports = light), "function" == typeof define && define.amd && define("light", [], function () { return light });